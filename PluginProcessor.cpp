/*
 ==============================================================================
 
 This file was auto-generated by the Introjucer!
 
 It contains the basic framework code for a JUCE plugin processor.
 
 ==============================================================================
 */

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include <math.h>
#include <algorithm>
#include "allPassFilter2.hpp"
#include "lowPassFilter2.hpp"
#include "Eigen/Core"

//class myReverb{
//private:
//    float fs;aca

//    
//    allPassFilter allPass1;
//    allPassFilter allPass2;
//    allPassFilter allPass3;
//    
//    int m[16];
//    
//    float allPass1Result;
//    float allPass2Result;
//    float allPass3Result;
//    float lowPassResult[16];
//    
//    Eigen::MatrixXf monoCoeff;
//    Eigen::MatrixXf feedbackMatrix;
//    Eigen::MatrixXf feedbackMatrix2;
//    Eigen::MatrixXf feedbackMatrix3;
//    Eigen::MatrixXf feedbackMatrix4;
//    Eigen::MatrixXf lowPassMatrix;
//    // Eigen::MatrixXf outOfDelayMatrix;
//    
//    lowPassFilter *lowPass[16];
//    circularBuffer<float>* delayLines[16];
//    float yOut;
//    int N1;
//    int N2;
//    int N3;
//    
//    float sampleBeforeDelayLine[16];  // this is the x1(n) in matlab code
//    float sampleOutOfDelayLine[16];  // this is the y1(n) in matlab code
//    
//public:
//    myReverb():allPass1(347),
//    allPass2(113),
//    allPass3(37),
//    monoCoeff(1,16),
//    feedbackMatrix(4,4),
//    feedbackMatrix2(4,4),
//    feedbackMatrix3(16,16),
//    feedbackMatrix4(16,16){
//        
//        feedbackMatrix<<1,-1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,-1,-1,1;
//        feedbackMatrix2 = 0.5*feedbackMatrix;
//        feedbackMatrix3 << feedbackMatrix2,-feedbackMatrix2,-feedbackMatrix2,-feedbackMatrix2,
//        -feedbackMatrix2,feedbackMatrix2,-feedbackMatrix2,-feedbackMatrix2,
//        -feedbackMatrix2,-feedbackMatrix2,feedbackMatrix2,-feedbackMatrix2,
//        -feedbackMatrix2,-feedbackMatrix2,-feedbackMatrix2,feedbackMatrix2;
//        feedbackMatrix4 = 0.5*feedbackMatrix3;
//        
//        monoCoeff<<1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;
//        m[0] =919;
//        m[1] = 997;
//        m[2] = 1061;
//        m[3] =1093;
//        m[4]=1129;
//        m[5]=1151;
//        m[6]=1171;
//        m[7]=1187;
//        m[8]=1213;
//        m[9]=1237;
//        m[10]=1259;
//        m[11]=1283;
//        m[12]=1303;
//        m[13]=1319;
//        m[14]= 1327;
//        m[15]=1361;
//        
//        for(int i=0; i<16; i++){
//            lowPassResult[i]=0;
//            //            m[i] = i+1;
//        }
//        
//        for(unsigned i=0; i<16; i++){
//            delayLines[i]=new circularBuffer<float>(m[i]+1);
//            lowPass[i] = new lowPassFilter();
//        }
//        
//    }
//    ~myReverb(){
//        for(unsigned i=0; i<16;i++){
//            delete delayLines[i];
//            delete lowPass[i];
//        }
//    }
//    
//    float process(float sample){
//        
//        allPass1Result = allPass1.process(sample);
//        allPass2Result = allPass2.process(allPass1Result);
//        allPass3Result = allPass3.process(allPass2Result);
//        //return allPass3Result;
//		
//        Eigen::Map<Eigen::MatrixXf> lowPassMatrixOriginal(lowPassResult,16,1);
//        lowPassMatrix = lowPassMatrixOriginal;
//        
//        //Eigen::Map<Eigen::MatrixXf> OutofDelayMatrixOriginal(sampleOutOfDelayLine, 16, 1);
//        
//        //outOfDelayMatrix = OutofDelayMatrixOriginal;
//        
//        
//        
//        yOut = allPass3Result+(monoCoeff.row(0)*lowPassMatrix)(0,0);
//        //            yOut = sample+(monoCoeff.row(0)*outOfDelayMatrix)(0,0);
//        
//        for (int delayLine = 0; delayLine<16; delayLine++) {
//            
//            sampleBeforeDelayLine[delayLine] = (feedbackMatrix4.row(delayLine)*lowPassMatrix)[0]+ allPass3Result;
//            //sampleBeforeDelayLine[delayLine] = (feedbackMatrix4.row(delayLine)*outOfDelayMatrix)[0]+ sample;
//            delayLines[delayLine]->writeFunction(sampleBeforeDelayLine[delayLine]);
//            sampleOutOfDelayLine[delayLine] = delayLines[delayLine]->readFunction(-1*m[delayLine]+1);
//            
//            
//            delayLines[delayLine]->moveReadPtr();
//            
//            lowPassResult[delayLine]= lowPass[delayLine]->process(sampleOutOfDelayLine[delayLine],delayLine);
//        }
//        
//        //yOut= lowPass.process(yOut,0);
//        //if(yOut>1) std::cout<<"clip!!"<<yOut<<std::endl;
//        return yOut;
//        
//        
//    }
//    
//    
//};
//
//


//==============================================================================
YingReverbAudioProcessor::YingReverbAudioProcessor()
{
    mix = 1;
}

YingReverbAudioProcessor::~YingReverbAudioProcessor()
{
}

//==============================================================================
const String YingReverbAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

int YingReverbAudioProcessor::getNumParameters()
{
    return 0;
}

float YingReverbAudioProcessor::getParameter (int index)
{
    return 0.0f;
}

void YingReverbAudioProcessor::setParameter (int index, float newValue)
{
}

const String YingReverbAudioProcessor::getParameterName (int index)
{
    return String();
}

const String YingReverbAudioProcessor::getParameterText (int index)
{
    return String();
}

const String YingReverbAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String YingReverbAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool YingReverbAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool YingReverbAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool YingReverbAudioProcessor::acceptsMidi() const
{
#if JucePlugin_WantsMidiInput
    return true;
#else
    return false;
#endif
}

bool YingReverbAudioProcessor::producesMidi() const
{
#if JucePlugin_ProducesMidiOutput
    return true;
#else
    return false;
#endif
}

bool YingReverbAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double YingReverbAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int YingReverbAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
    // so this should be at least 1, even if you're not really implementing programs.
}

int YingReverbAudioProcessor::getCurrentProgram()
{
    return 0;
}

void YingReverbAudioProcessor::setCurrentProgram (int index)
{
}

const String YingReverbAudioProcessor::getProgramName (int index)
{
    return String();
}

void YingReverbAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void YingReverbAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
}

void YingReverbAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}
//myReverb reverb;


void YingReverbAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    
    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // I've added this to avoid people getting screaming feedback
    // when they first compile the plugin, but obviously you don't need to
    // this code if your algorithm already fills all the output channels.
    int numSamples;
    numSamples = buffer.getNumSamples();
for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
        buffer.clear (i, 0, buffer.getNumSamples());
    // This is the place where you'd normally do the guts of your plugin's
    // audio processing...
 
   // for (int channel = 0; channel < getNumInputChannels(); ++channel)
    //{
        const float* channelData = buffer.getReadPointer(0);
    
        float* channelDataOut = buffer.getWritePointer(0);
        for (int sampleInBuffer=0; sampleInBuffer<numSamples; sampleInBuffer++) {
            channelDataOut[sampleInBuffer] =(mix*reverb.process(channelData[sampleInBuffer])+(1-mix)*channelData[sampleInBuffer]/6)/2;
            //channelDataOut[sampleInBuffer] =channelData[sampleInBuffer];
           // channelDataOut[sampleInBuffer] =mix*reverb.process(channelData[sampleInBuffer]);
        }
   // std::cout<<"para1 = "<<T60<<'\n';
        // ..do something to the data...
    //}
    
}



//==============================================================================
bool YingReverbAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* YingReverbAudioProcessor::createEditor()
{
    return new YingReverbAudioProcessorEditor (*this);
}

//==============================================================================
void YingReverbAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void YingReverbAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new YingReverbAudioProcessor();
}
