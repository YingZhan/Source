/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#ifndef PLUGINPROCESSOR_H_INCLUDED
#define PLUGINPROCESSOR_H_INCLUDED

#include "../JuceLibraryCode/JuceHeader.h"
#include "/Users/cherry1991/Desktop/Source/allPassFilter2.hpp"
#include "/Users/cherry1991/Desktop/Source/lowPassFilter2.hpp"
#include "/Users/cherry1991/Desktop/Source/Eigen/Core"
#include "toneCorrection.hpp"

 static int m[] ={
    919,997,1061,1093,1129,1151,1171,1187,1213,1237,1259,1283,1303,1319,1327,1361
};



//==============================================================================
/**
*/
class myReverb{
private:
    float fs;
    toneCorrection toneCorrectionFilter;
    allPassFilter allPass1;
    allPassFilter allPass2;
    allPassFilter allPass3;
    
   
    
    float allPass1Result;
    float allPass2Result;
    float allPass3Result;
    float toneCorrectionResult;
    float lowPassResult[16];
    
    Eigen::MatrixXf monoCoeff;
    Eigen::MatrixXf feedbackMatrix;
    Eigen::MatrixXf feedbackMatrix2;
    Eigen::MatrixXf feedbackMatrix3;
    Eigen::MatrixXf feedbackMatrix4;
    Eigen::MatrixXf lowPassMatrix;
    // Eigen::MatrixXf outOfDelayMatrix;
    
   // lowPassFilter *lowPass[16];
    circularBuffer<float>* delayLines[16];
    float yOut;
    int N1;
    int N2;
    int N3;
    
    float sampleBeforeDelayLine[16];  // this is the x1(n) in matlab code
    float sampleOutOfDelayLine[16];  // this is the y1(n) in matlab code
    
public:
    lowPassFilter *lowPass[16];
    myReverb():allPass1(347),
    allPass2(113),
    allPass3(37),
    monoCoeff(1,16),
    feedbackMatrix(4,4),
    feedbackMatrix2(4,4),
    feedbackMatrix3(16,16),
    feedbackMatrix4(16,16){
        
        feedbackMatrix<<1,-1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,-1,-1,1;
        feedbackMatrix2 = 0.5*feedbackMatrix;
        feedbackMatrix3 << feedbackMatrix2,-feedbackMatrix2,-feedbackMatrix2,-feedbackMatrix2,
        -feedbackMatrix2,feedbackMatrix2,-feedbackMatrix2,-feedbackMatrix2,
        -feedbackMatrix2,-feedbackMatrix2,feedbackMatrix2,-feedbackMatrix2,
        -feedbackMatrix2,-feedbackMatrix2,-feedbackMatrix2,feedbackMatrix2;
        feedbackMatrix4 = 0.5*feedbackMatrix3;
        
        monoCoeff<<1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;

        
        for(int i=0; i<16; i++){
            lowPassResult[i]=0;
            //            m[i] = i+1;
        }
       
        
        for(unsigned i=0; i<16; i++){
            delayLines[i]=new circularBuffer<float>(m[i]+1);
            lowPass[i] = new lowPassFilter(44100);
        }
        fs=44100;
        setReverbTime(3);
        //std::cout<<"initializeFinished";
        
    }
    ~myReverb(){
        for(unsigned i=0; i<16;i++){
            delete delayLines[i];
            delete lowPass[i];
        }
    }
    
    void setReverbTime(float reverbTimeInSecond) {
        float t60 = reverbTimeInSecond;
        
        //t60=3;
        float q = 1.25/3;  // right now, damping rate from low to high is fixed (one of possible parameters)
        for (int line = 0; line<16; line++) {
            float kp = pow(10,-3*m[line]/(fs*t60));
            float bp = 20* log10(kp)*log(10)/80*(1-1/(q*q));
           // std::cout<<kp<<" "<<bp<<std::endl;
            lowPass[line]->setParam(kp,bp);
            
        };
    }
    
        
        
    
    
    float process(float sample){
        
//        allPass1Result = allPass1.process(sample);
//        allPass2Result = allPass2.process(allPass1Result);
//        allPass3Result = allPass3.process(allPass2Result);
        //return allPass3Result;
        
		toneCorrectionResult = toneCorrectionFilter.process(sample);
        Eigen::Map<Eigen::MatrixXf> lowPassMatrixOriginal(lowPassResult,16,1);
        lowPassMatrix = lowPassMatrixOriginal;
        
        //Eigen::Map<Eigen::MatrixXf> OutofDelayMatrixOriginal(sampleOutOfDelayLine, 16, 1);
        
        //outOfDelayMatrix = OutofDelayMatrixOriginal;
        
        
        
        yOut = allPass3Result+(monoCoeff.row(0)*lowPassMatrix)(0,0);
        //            yOut = sample+(monoCoeff.row(0)*outOfDelayMatrix)(0,0);
        
        for (int delayLine = 0; delayLine<16; delayLine++) {
           sampleBeforeDelayLine[delayLine] = (feedbackMatrix4.row(delayLine)*lowPassMatrix)[0]+ toneCorrectionResult;
//            sampleBeforeDelayLine[delayLine] = (feedbackMatrix4.row(delayLine)*lowPassMatrix)[0]+ allPass3Result;
            //sampleBeforeDelayLine[delayLine] = (feedbackMatrix4.row(delayLine)*outOfDelayMatrix)[0]+ sample;
            delayLines[delayLine]->writeFunction(sampleBeforeDelayLine[delayLine]);
            sampleOutOfDelayLine[delayLine] = delayLines[delayLine]->readFunction(-1*m[delayLine]+1);
            
            
            delayLines[delayLine]->moveReadPtr();
            
            lowPassResult[delayLine]= lowPass[delayLine]->process(sampleOutOfDelayLine[delayLine]);
            //lowPassResult[delayLine]= sampleOutOfDelayLine[delayLine];

        }
        
        //yOut= lowPass.process(yOut,0);
        //if(yOut>1) std::cout<<"clip!!"<<yOut<<std::endl;
        //std::cout<<yOut;
        return yOut/6;
        
        
    }
    
    
};




class YingReverbAudioProcessor  : public AudioProcessor
{
public:
    //==============================================================================
    YingReverbAudioProcessor();
    ~YingReverbAudioProcessor();
    
    
    float mix;
   
    myReverb reverb;
    //==============================================================================
    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;

    void processBlock (AudioSampleBuffer&, MidiBuffer&) override;

    //==============================================================================
    AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override;

    //==============================================================================
    const String getName() const override;

    int getNumParameters() override;
    float getParameter (int index) override;
    void setParameter (int index, float newValue) override;

    const String getParameterName (int index) override;
    const String getParameterText (int index) override;

    const String getInputChannelName (int channelIndex) const override;
    const String getOutputChannelName (int channelIndex) const override;
    bool isInputChannelStereoPair (int index) const override;
    bool isOutputChannelStereoPair (int index) const override;

    bool acceptsMidi() const override;
    bool producesMidi() const override;
    bool silenceInProducesSilenceOut() const override;
    double getTailLengthSeconds() const override;

    //==============================================================================
    int getNumPrograms() override;
    int getCurrentProgram() override;
    void setCurrentProgram (int index) override;
    const String getProgramName (int index) override;
    void changeProgramName (int index, const String& newName) override;

    //==============================================================================
    void getStateInformation (MemoryBlock& destData) override;
    void setStateInformation (const void* data, int sizeInBytes) override;

private:
    //==============================================================================
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (YingReverbAudioProcessor)
};


#endif  // PLUGINPROCESSOR_H_INCLUDED
